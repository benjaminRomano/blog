"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[577],{5530:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"instruments-flame-graphs","metadata":{"permalink":"/blog/blog/instruments-flame-graphs","source":"@site/blog/parsing-xctrace/index.mdx","title":"Creating Flame Graphs from Time Profiler Data","description":"Background","date":"2023-11-10T00:00:00.000Z","formattedDate":"November 10, 2023","tags":[{"label":"sampling profiler","permalink":"/blog/blog/tags/sampling-profiler"}],"readingTime":7.5,"hasTruncateMarker":false,"authors":[],"frontMatter":{"slug":"instruments-flame-graphs","title":"Creating Flame Graphs from Time Profiler Data","tags":["sampling profiler"],"date":"2023-11-10T00:00:00.000Z"},"unlisted":false},"content":"## Background\\n\\nRecently, I\'ve begun doing iOS performance engineering and have been exploring Instruments for collecting and analyzing\\nperformance data. Typically, my performance workflow begins by collecting sampling profiler data, which can be easily\\ndone using Instrument\'s Time Profiler. With sampling profiler data, I first look at where the most CPU time is being\\nspent using [Flame Graphs](https://www.brendangregg.com/flamegraphs.html) or analyze the flow of execution by looking at\\nStack Charts (time-ordered samples). Surprisingly, Instruments does not provide these views. It only provides a Call\\nTree view.\\n\\n<figure>\\n  <img src={require(\\"./imgs/TimeProfiler.png\\").default} alt=\\"Time Profiler for Console app\'s main thread\\" />\\n  <figcaption>Call Tree view of Console app\'s main thread</figcaption>\\n</figure>\\n\\nTo address this, I built [instruments-to-gecko](https://github.com/benjaminRomano/instruments-to-gecko), which converts\\nInstrument\'s trace format into the Gecko format used by\\n[Firefox Profiler](https://github.com/firefox-devtools/profiler), a powerful browser-based sampling profiler viewer.\\n\\n<figure>\\n  <img src={require(\\"./imgs/StackChart.png\\").default} alt=\\"Stack Chart View of Console app\\" />\\n  <figcaption>\\n    Stack Chart View of Console app\'s main thread in Firefox Profiler ([Example](https://share.firefox.dev/46a3hBR))\\n  </figcaption>\\n</figure>\\n\\nWhile building this tool, I ran into some challenges extracting symbolicated call stacks, the call stack with the\\noriginal symbols (i.e. function names), from traces. Using some clever tricks, I was able to find a path forward until\\nsupport for extracting symbolicated call stacks from traces was introduced in\\n[XCode 14.3](https://developer.apple.com/forums/thread/708957). Although the workaround is no longer necessary, the\\nprocess is still instructive to walk through as it demystifies symbolication and trace data extraction.\\n\\n## Instrument\'s Trace Format\\n\\nTo start, traces are effectively a directory with binary-encoded files nested within. The specifications for those files\\nis not public; but, it can technically be reverse engineered using\\n[private headers](https://github.com/Qusic/TraceUtility).\\n\\nFortunately, in XCode 12, Apple introduced `xctrace`, a command line utility, to programmatically expose the underlying\\ndata as XML. By using the command, `xctrace export --input <INPUT> --toc`, a table of contents for the trace can be\\nexported:\\n\\n```xml\\n    ...\\n    <run number=\\"1\\">\\n        ...\\n        <data>\\n            \x3c!-- Time profile table --\x3e\\n            <table target-pid=\\"SINGLE\\" context-switch-sampling=\\"0\\" high-frequency-sampling=\\"0\\" schema=\\"time-profile\\" needs-kernel-callstack=\\"0\\" record-waiting-threads=\\"0\\"/>\\n            \x3c!-- KDebug strings --\x3e\\n            <table codes=\\"&quot;33,0x11&quot;\\" schema=\\"kdebug-strings\\" target=\\"SINGLE\\"/>\\n            \x3c!-- KDebug events --\x3e\\n            <table codes=\\"&quot;46,2&quot;\\" schema=\\"kdebug\\" callstack=\\"user\\" target=\\"SINGLE\\"/>\\n            \x3c!-- More tables... --\x3e\\n        </data>\\n    </run>\\n```\\n\\nAlternatively, the data within the trace can be interactively explored using Instrument\'s Inspector window\\n(`Document > Inspector`).\\n\\n<figure>\\n  <img src={require(\\"./imgs/Inspector.png\\").default} alt=\\"XCode Inspector Window\\" />\\n  <figcaption>Instrument\'s Inspector Window</figcaption>\\n</figure>\\n\\n### Time Profiler Data\\n\\nFrom the table of contents, we saw that there was a Time Profiler table within the trace. Data from this table can\\nsubsequently be exported by passing an `xpath` to `xctrace`:\\n\\n```bash\\nxctrace export --input <TRACE> --xpath \'/trace-toc[1]/run[1]/data[1]/table[@schema=\\"time-profile\\"]\'\\n```\\n\\nThis outputs a list of rows with each row corresponding to a sample collected by Time Profiler. Specifically, the row\\ncontains when the sample was collected, which thread it was collected from and the backtrace. Before XCode 14.3, the\\nbacktrace would only contain the raw addresses and **not** the symbols.\\n\\n```xml\\n <row>\\n    \x3c!-- Time at which the sample was collected --\x3e\\n     <sample-time id=\\"177\\" fmt=\\"00:00.411.046\\">411046250</sample-time>\\n    \x3c!-- The thread the sample was collected on. --\x3e\\n    <thread id=\\"54\\" fmt=\\"_dispatch_workloop_worker_thread  0x627b (Instruments, pid: 3221)\\">\\n        <tid id=\\"55\\" fmt=\\"0x627b\\">25211</tid>\\n        <process ref=\\"40\\"/>\\n    </thread>\\n     <process ref=\\"40\\"/>\\n    <core ref=\\"171\\"/><thread-state ref=\\"172\\"/>\\n    <weight ref=\\"173\\"/>\\n     \x3c!-- The backtrace of the sample --\x3e\\n     \x3c!--  Each `text-address` corresponds to a frame in the call stack sampled --\x3e\\n     <backtrace id=\\"178\\" fmt=\\"0x11d690681 \u2190 (1 other frames)\\">\\n        <process ref=\\"40\\"/>\\n         \x3c!-- Text Address is the raw address for a given frame --\x3e\\n        <text-addresses id=\\"179\\" fmt=\\"frag 801\\">4788389505</text-addresses>\\n        <process ref=\\"40\\"/>\\n         <text-addresses id=\\"180\\" fmt=\\"frag 802\\">4788032064</text-addresses>\\n     </backtrace>\\n</row>\\n```\\n\\n:::tip Reference Nodes\\n\\nGiven the table is quite large and XML is verbose, `xctrace` uses \\"reference\\" nodes to avoid duplicating data. In the\\nexample below, the `<process>` node has a `ref` attribute which points back to an \\"original\\" node (a node with an `id`\\nattribute).\\n\\n```xml\\n\x3c!-- Original node --\x3e\\n<process id=\\"40\\" fmt=\\"Console (3221)\\">\\n    <pid id=\\"5\\" fmt=\\"3221\\">3221</pid>\\n</process>\\n\\n\x3c!-- Reference node --\x3e\\n<process ref=\\"40\\" />\\n```\\n\\n:::\\n\\n## Symbolicating Backtraces\\n\\nNow that we\'ve gotten the backtraces, the next step is to figure out how to symbolicate the raw addresses back to the\\noriginal symbol.\\n\\nIn theory, symbolication is quite simple. Source code is compiled into a binary containing functions and their\\nassociated instructions. Then, the address of a function is roughly just the byte offset into the binary. Additionally,\\nat compile-time debug symbols[^1] are generated which provides a mapping of the function address to the original symbol.\\nGiven a backtrace, which is just a stack of function addresses, we can take the debug symbols and trivially symbolicate.\\n\\nUnfortunately in practice, symbolication is not that easy. At runtime, a function\'s address is not equivalent to the\\nbyte offset of the function within the binary. A binary is mapped into virtual memory at an arbitrary address[^2]. If it\\nwasn\'t, the function addresses of two binaries would conflict!\\n\\nSo to symbolicate, we need three things:\\n\\n1. **Debug Symbols** - the mapping of function addresses to symbols\\n2. **Raw Address** - the function address in virtual memory\\n3. **Load Address** - the starting address of the binary in virtual memory\\n\\nBy subtracting the Load Address from the Raw Address, we get the original address (i.e. byte offset of the function in\\nthe binary) and can use the debug symbols to map back to the symbol.\\n\\nThis is effectively what Instrument\'s Time Profiler UI does behind the scenes to render symbolicated call stacks.\\nNotably, Instruments allows call stacks to be symbolicated at a later time so the trace _must_ be storing the load\\naddresses for each binary referenced.\\n\\nNow the question is, can we extract the load addresses from traces using `xctrace`?\\n\\n### Finding Load Addresses\\n\\nGoing back to the Table of Contents, we see that there is a `kdebug` table, containing kernel debug tracepoints, and a\\n`kdebug-strings` table containing strings referenced by those kernel tracepoints.\\n\\nFortunately, `dyld`, the library responsible for dynamically loading libraries, does emit a\\n[kdebug tracepoint](https://github.com/apple-oss-distributions/dyld/blob/c8a445f88f9fc1713db34674e79b00e30723e79d/dyld/dyldMain.cpp#L376)\\nwith both the binary name and load address.\\n\\n```c\\n// call kdebug trace for each image\\nif ( kdebug_is_enabled(KDBG_CODE(DBG_DYLD, DBG_DYLD_UUID, DBG_DYLD_UUID_MAP_A)) ) {\\n    // add trace for dyld_sim itself\\n    uuid_t dyldUuid;\\n    ((MachOAnalyzer*)dyldSimLoadAddress)->getUuid(dyldUuid);\\n    fsid_t             dyldFsid    = { { sb.st_dev, 0 } };\\n    fsobj_id_t         dyldFfsobjid = *(fsobj_id_t*)&sb.st_ino;\\n    dyld3::kdebug_trace_dyld_image(DBG_DYLD_UUID_MAP_A, info.imageFilePath, &dyldUuid, dyldFfsobjid, dyldFsid, info.imageLoadAddress);\\n}\\n```\\n\\nFollowing through the indirection and arch-specific logic of `dyld3::kdebug_trace_dyld_image`, we can determine the data\\nis emitted through the following sequence of tracepoints in the `kdebug` table:\\n\\n```xml\\n\x3c!-- KDBG_CODE(DBG_DYLD, DBG_DYLD_UUID, DBG_DYLD_UUID_MAP_A) --\x3e\\n<row>\\n    <kdebug-class id=\\"...\\" fmt=\\"0x1F\\">31</kdebug-class>\\n    <kdebug-subclass id=\\"...\\" fmt=\\"0x5\\">5</kdebug-subclass>\\n    <kdebug-code id=\\"...\\" fmt=\\"0x0\\">0</kdebug-code>\\n    \x3c!-- String ID pointing to binary --\x3e\\n    <kdebug-arg id=\\"...\\" fmt=\\"0x86a4\\">34468</kdebug-arg>\\n    ...\\n</row>\\n\x3c!-- KDBG_CODE(DBG_DYLD, DBG_DYLD_UUID, DBG_DYLD_UUID_MAP_B) --\x3e\\n<row>\\n    <kdebug-class id=\\"...\\" fmt=\\"0x1F\\">31</kdebug-class>\\n    <kdebug-subclass id=\\"...\\" fmt=\\"0x5\\">5</kdebug-subclass>\\n    <kdebug-code id=\\"...\\" fmt=\\"0x0\\">0</kdebug-code>\\n    <kdebug-arg id=\\"...\\" fmt=\\"...\\">...</kdebug-arg>\\n    \x3c!-- Load Address --\x3e\\n    <kdebug-arg id=\\"...\\" fmt=\\"0x86a4\\">34468</kdebug-arg>\\n    ...\\n</row>\\n```\\n\\nLastly, we can take the string ID in the kdebug arg and map it back to the binary name using the `kdebug-string` table:\\n\\n```xml\\n\x3c!-- fmt attribute contains the string ID --\x3e\\n<string id=\\"1\\" fmt=\\"34468\\">\\n    <raw-string>{binary name}</raw-string>\\n</string>\\n```\\n\\n### Finding Debug Symbols\\n\\nThe last bit before symbolicating is finding the debug symbols. For System Frameworks on iOS \\\\<17, these are stored\\nunder the DeviceSupport directory. For example:\\n\\n```bash\\n~/Library/Developer/Xcode/iOS\\\\ DeviceSupport/16.1\\\\ \\\\(20B82\\\\)\\\\ arm64e/Symbols/<libraryName>\\n```\\n\\nFor your own application, a `.dSYM` file can be generated by setting `Debugging Information Format` for the XCode\\nproject to `DWARF with dSYM File`.\\n\\n### Symbolicating\\n\\nFinally, we can symbolicate by using `atos` which takes in a `.dSYM`, a load address and a list of addresses. For each\\nbinary loaded, we need to pass the entire list of addresses observed in the backtraces. If the `.dSYM` contains a match\\nfor the address, the output will contain the symbol name; otherwise, the address passed in will be returned.\\n\\n```bash\\n# arm64e for physical devices, x86_64 for simulators on Intel macs\\n# Provide a file with all possible addresses in hex format (e.g. 0x11d690681)\\n# The output will contain either the original address if no match is found or the matching symbol\\n#\\n# Note: This is quite slow. It takes ~1m30s to process ~800 dSYMs even with parallelization on an M1.\\natos -arch arm64e -o <dSymFile> -l <loadAddress> -f <file with all addresses>\\n```\\n\\nAfter iterating through all `.dSYM` files, the list should be fully symbolicated. Lastly, iterate through the backtraces\\nusing the newly generated address to symbols mapping to complete the symbolication process. The symbolicated call stacks\\ncan then be converted into arbitrary profile data formats, like\\n[Gecko](https://github.com/firefox-devtools/profiler/blob/main/docs-developer/gecko-profile-format.md).\\n\\n## Conclusion\\n\\nOverall, the approach outlined is complex and brittle. With XCode 14.3, `xctrace` now exports symbolicated backtraces\\nremoving the necessity for any of this complexity.\\n\\n```xml\\n\x3c!-- Example XCode 14.3+ backtrace --\x3e\\n<backtrace id=\\"182\\">\\n    <frame id=\\"183\\" name=\\"tiny_malloc_should_clear\\" addr=\\"0x7ff813c8cd06\\">...</frame>\\n    <frame id=\\"185\\" name=\\"szone_malloc_should_clear\\" addr=\\"0x7ff813c8bc3a\\">...</frame>\\n    <frame id=\\"186\\" name=\\"__CFBasicHashRehash\\" addr=\\"0x7ff813ed35a4\\">...</frame>\\n    <frame id=\\"188\\" name=\\"__CFBasicHashAddValue\\" addr=\\"0x7ff813ed3145\\">...</frame>\\n</backtrace>\\n```\\n\\nThe last code for converting Instruments to Gecko can be found\\n[here](https://github.com/benjaminRomano/instruments-to-gecko/tree/main) and pre-XCode 14.3 implementation\\n[here](https://github.com/benjaminRomano/instruments-to-gecko/tree/9ea14be77205a6313694467ac409471bad21be75).\\n\\n_Special thanks to Alejandro Lucena who proposed the `dyld` KDebug tracepoint approach for finding load addresses_\\n\\n[^1]:\\n    Debug Symbols can either be embedded within the binary using the DWARF format or exported into a debug symbols file\\n    (`.dSYM`)\\n\\n[^2]:\\n    And for good measure, usually an arbitrarily different address each time due to address space layout randomization\\n    ([ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization))"}]}')}}]);