"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[916],{4776:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var s=t(5893),a=t(1151);const i={slug:"instruments-flame-graphs",title:"Creating Flame Graphs from Time Profiler Data",tags:["sampling profiler"],date:new Date("2023-11-10T00:00:00.000Z")},r=void 0,o={permalink:"/blog/instruments-flame-graphs",source:"@site/blog/parsing-xctrace/index.mdx",title:"Creating Flame Graphs from Time Profiler Data",description:"Background",date:"2023-11-10T00:00:00.000Z",formattedDate:"November 10, 2023",tags:[{label:"sampling profiler",permalink:"/blog/tags/sampling-profiler"}],readingTime:7.5,hasTruncateMarker:!1,authors:[],frontMatter:{slug:"instruments-flame-graphs",title:"Creating Flame Graphs from Time Profiler Data",tags:["sampling profiler"],date:"2023-11-10T00:00:00.000Z"},unlisted:!1},d={authorsImageUrls:[]},c=[{value:"Background",id:"background",level:2},{value:"Instrument&#39;s Trace Format",id:"instruments-trace-format",level:2},{value:"Time Profiler Data",id:"time-profiler-data",level:3},{value:"Symbolicating Backtraces",id:"symbolicating-backtraces",level:2},{value:"Finding Load Addresses",id:"finding-load-addresses",level:3},{value:"Finding Debug Symbols",id:"finding-debug-symbols",level:3},{value:"Symbolicating",id:"symbolicating",level:3},{value:"Conclusion",id:"conclusion",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,s.jsxs)(n.p,{children:["Recently, I've begun doing iOS performance engineering and have been exploring Instruments for collecting and analyzing\nperformance data. Typically, my performance workflow begins by collecting sampling profiler data, which can be easily\ndone using Instrument's Time Profiler. With sampling profiler data, I first look at where the most CPU time is being\nspent using ",(0,s.jsx)(n.a,{href:"https://www.brendangregg.com/flamegraphs.html",children:"Flame Graphs"})," or analyze the flow of execution by looking at\nStack Charts (time-ordered samples). Surprisingly, Instruments does not provide these views. It only provides a Call\nTree view."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:t(7736).Z,alt:"Time Profiler for Console app's main thread"}),(0,s.jsx)("figcaption",{children:"Call Tree view of Console app's main thread"})]}),"\n",(0,s.jsxs)(n.p,{children:["To address this, I built ",(0,s.jsx)(n.a,{href:"https://github.com/benjaminRomano/instruments-to-gecko",children:"instruments-to-gecko"}),", which converts\nInstrument's trace format into the Gecko format used by\n",(0,s.jsx)(n.a,{href:"https://github.com/firefox-devtools/profiler",children:"Firefox Profiler"}),", a powerful browser-based sampling profiler viewer."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:t(3389).Z,alt:"Stack Chart View of Console app"}),(0,s.jsx)("figcaption",{children:(0,s.jsxs)(n.p,{children:["Stack Chart View of Console app's main thread in Firefox Profiler (",(0,s.jsx)(n.a,{href:"https://share.firefox.dev/46a3hBR",children:"Example"}),")"]})})]}),"\n",(0,s.jsxs)(n.p,{children:["While building this tool, I ran into some challenges extracting symbolicated call stacks, the call stack with the\noriginal symbols (i.e. function names), from traces. Using some clever tricks, I was able to find a path forward until\nsupport for extracting symbolicated call stacks from traces was introduced in\n",(0,s.jsx)(n.a,{href:"https://developer.apple.com/forums/thread/708957",children:"XCode 14.3"}),". Although the workaround is no longer necessary, the\nprocess is still instructive to walk through as it demystifies symbolication and trace data extraction."]}),"\n",(0,s.jsx)(n.h2,{id:"instruments-trace-format",children:"Instrument's Trace Format"}),"\n",(0,s.jsxs)(n.p,{children:["To start, traces are effectively a directory with binary-encoded files nested within. The specifications for those files\nis not public; but, it can technically be reverse engineered using\n",(0,s.jsx)(n.a,{href:"https://github.com/Qusic/TraceUtility",children:"private headers"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Fortunately, in XCode 12, Apple introduced ",(0,s.jsx)(n.code,{children:"xctrace"}),", a command line utility, to programmatically expose the underlying\ndata as XML. By using the command, ",(0,s.jsx)(n.code,{children:"xctrace export --input <INPUT> --toc"}),", a table of contents for the trace can be\nexported:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'    ...\n    <run number="1">\n        ...\n        <data>\n            \x3c!-- Time profile table --\x3e\n            <table target-pid="SINGLE" context-switch-sampling="0" high-frequency-sampling="0" schema="time-profile" needs-kernel-callstack="0" record-waiting-threads="0"/>\n            \x3c!-- KDebug strings --\x3e\n            <table codes="&quot;33,0x11&quot;" schema="kdebug-strings" target="SINGLE"/>\n            \x3c!-- KDebug events --\x3e\n            <table codes="&quot;46,2&quot;" schema="kdebug" callstack="user" target="SINGLE"/>\n            \x3c!-- More tables... --\x3e\n        </data>\n    </run>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Alternatively, the data within the trace can be interactively explored using Instrument's Inspector window\n(",(0,s.jsx)(n.code,{children:"Document > Inspector"}),")."]}),"\n",(0,s.jsxs)("figure",{children:[(0,s.jsx)("img",{src:t(2176).Z,alt:"XCode Inspector Window"}),(0,s.jsx)("figcaption",{children:"Instrument's Inspector Window"})]}),"\n",(0,s.jsx)(n.h3,{id:"time-profiler-data",children:"Time Profiler Data"}),"\n",(0,s.jsxs)(n.p,{children:["From the table of contents, we saw that there was a Time Profiler table within the trace. Data from this table can\nsubsequently be exported by passing an ",(0,s.jsx)(n.code,{children:"xpath"})," to ",(0,s.jsx)(n.code,{children:"xctrace"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"xctrace export --input <TRACE> --xpath '/trace-toc[1]/run[1]/data[1]/table[@schema=\"time-profile\"]'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This outputs a list of rows with each row corresponding to a sample collected by Time Profiler. Specifically, the row\ncontains when the sample was collected, which thread it was collected from and the backtrace. Before XCode 14.3, the\nbacktrace would only contain the raw addresses and ",(0,s.jsx)(n.strong,{children:"not"})," the symbols."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:' <row>\n    \x3c!-- Time at which the sample was collected --\x3e\n     <sample-time id="177" fmt="00:00.411.046">411046250</sample-time>\n    \x3c!-- The thread the sample was collected on. --\x3e\n    <thread id="54" fmt="_dispatch_workloop_worker_thread  0x627b (Instruments, pid: 3221)">\n        <tid id="55" fmt="0x627b">25211</tid>\n        <process ref="40"/>\n    </thread>\n     <process ref="40"/>\n    <core ref="171"/><thread-state ref="172"/>\n    <weight ref="173"/>\n     \x3c!-- The backtrace of the sample --\x3e\n     \x3c!--  Each `text-address` corresponds to a frame in the call stack sampled --\x3e\n     <backtrace id="178" fmt="0x11d690681 \u2190 (1 other frames)">\n        <process ref="40"/>\n         \x3c!-- Text Address is the raw address for a given frame --\x3e\n        <text-addresses id="179" fmt="frag 801">4788389505</text-addresses>\n        <process ref="40"/>\n         <text-addresses id="180" fmt="frag 802">4788032064</text-addresses>\n     </backtrace>\n</row>\n'})}),"\n",(0,s.jsxs)(n.admonition,{title:"Reference Nodes",type:"tip",children:[(0,s.jsxs)(n.p,{children:["Given the table is quite large and XML is verbose, ",(0,s.jsx)(n.code,{children:"xctrace"}),' uses "reference" nodes to avoid duplicating data. In the\nexample below, the ',(0,s.jsx)(n.code,{children:"<process>"})," node has a ",(0,s.jsx)(n.code,{children:"ref"}),' attribute which points back to an "original" node (a node with an ',(0,s.jsx)(n.code,{children:"id"}),"\nattribute)."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Original node --\x3e\n<process id="40" fmt="Console (3221)">\n    <pid id="5" fmt="3221">3221</pid>\n</process>\n\n\x3c!-- Reference node --\x3e\n<process ref="40" />\n'})})]}),"\n",(0,s.jsx)(n.h2,{id:"symbolicating-backtraces",children:"Symbolicating Backtraces"}),"\n",(0,s.jsx)(n.p,{children:"Now that we've gotten the backtraces, the next step is to figure out how to symbolicate the raw addresses back to the\noriginal symbol."}),"\n",(0,s.jsxs)(n.p,{children:["In theory, symbolication is quite simple. Source code is compiled into a binary containing functions and their\nassociated instructions. Then, the address of a function is roughly just the byte offset into the binary. Additionally,\nat compile-time debug symbols",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-1-086523",id:"user-content-fnref-1-086523","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," are generated which provides a mapping of the function address to the original symbol.\nGiven a backtrace, which is just a stack of function addresses, we can take the debug symbols and trivially symbolicate."]}),"\n",(0,s.jsxs)(n.p,{children:["Unfortunately in practice, symbolication is not that easy. At runtime, a function's address is not equivalent to the\nbyte offset of the function within the binary. A binary is mapped into virtual memory at an arbitrary address",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-2-086523",id:"user-content-fnref-2-086523","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),". If it\nwasn't, the function addresses of two binaries would conflict!"]}),"\n",(0,s.jsx)(n.p,{children:"So to symbolicate, we need three things:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debug Symbols"})," - the mapping of function addresses to symbols"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raw Address"})," - the function address in virtual memory"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Load Address"})," - the starting address of the binary in virtual memory"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By subtracting the Load Address from the Raw Address, we get the original address (i.e. byte offset of the function in\nthe binary) and can use the debug symbols to map back to the symbol."}),"\n",(0,s.jsxs)(n.p,{children:["This is effectively what Instrument's Time Profiler UI does behind the scenes to render symbolicated call stacks.\nNotably, Instruments allows call stacks to be symbolicated at a later time so the trace ",(0,s.jsx)(n.em,{children:"must"})," be storing the load\naddresses for each binary referenced."]}),"\n",(0,s.jsxs)(n.p,{children:["Now the question is, can we extract the load addresses from traces using ",(0,s.jsx)(n.code,{children:"xctrace"}),"?"]}),"\n",(0,s.jsx)(n.h3,{id:"finding-load-addresses",children:"Finding Load Addresses"}),"\n",(0,s.jsxs)(n.p,{children:["Going back to the Table of Contents, we see that there is a ",(0,s.jsx)(n.code,{children:"kdebug"})," table, containing kernel debug tracepoints, and a\n",(0,s.jsx)(n.code,{children:"kdebug-strings"})," table containing strings referenced by those kernel tracepoints."]}),"\n",(0,s.jsxs)(n.p,{children:["Fortunately, ",(0,s.jsx)(n.code,{children:"dyld"}),", the library responsible for\n",(0,s.jsx)(n.a,{href:"https://www.emergetools.com/glossary/dyld",children:"dynamically loading libraries"}),", does emit a\n",(0,s.jsx)(n.a,{href:"https://github.com/apple-oss-distributions/dyld/blob/c8a445f88f9fc1713db34674e79b00e30723e79d/dyld/dyldMain.cpp#L376",children:"kdebug tracepoint"}),"\nwith both the binary name and load address."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"// call kdebug trace for each image\nif ( kdebug_is_enabled(KDBG_CODE(DBG_DYLD, DBG_DYLD_UUID, DBG_DYLD_UUID_MAP_A)) ) {\n    // add trace for dyld_sim itself\n    uuid_t dyldUuid;\n    ((MachOAnalyzer*)dyldSimLoadAddress)->getUuid(dyldUuid);\n    fsid_t             dyldFsid    = { { sb.st_dev, 0 } };\n    fsobj_id_t         dyldFfsobjid = *(fsobj_id_t*)&sb.st_ino;\n    dyld3::kdebug_trace_dyld_image(DBG_DYLD_UUID_MAP_A, info.imageFilePath, &dyldUuid, dyldFfsobjid, dyldFsid, info.imageLoadAddress);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Following through the indirection and arch-specific logic of ",(0,s.jsx)(n.code,{children:"dyld3::kdebug_trace_dyld_image"}),", we can determine the data\nis emitted through the following sequence of tracepoints in the ",(0,s.jsx)(n.code,{children:"kdebug"})," table:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- KDBG_CODE(DBG_DYLD, DBG_DYLD_UUID, DBG_DYLD_UUID_MAP_A) --\x3e\n<row>\n    <kdebug-class id="..." fmt="0x1F">31</kdebug-class>\n    <kdebug-subclass id="..." fmt="0x5">5</kdebug-subclass>\n    <kdebug-code id="..." fmt="0x0">0</kdebug-code>\n    \x3c!-- String ID pointing to binary --\x3e\n    <kdebug-arg id="..." fmt="0x86a4">34468</kdebug-arg>\n    ...\n</row>\n\x3c!-- KDBG_CODE(DBG_DYLD, DBG_DYLD_UUID, DBG_DYLD_UUID_MAP_B) --\x3e\n<row>\n    <kdebug-class id="..." fmt="0x1F">31</kdebug-class>\n    <kdebug-subclass id="..." fmt="0x5">5</kdebug-subclass>\n    <kdebug-code id="..." fmt="0x0">0</kdebug-code>\n    <kdebug-arg id="..." fmt="...">...</kdebug-arg>\n    \x3c!-- Load Address --\x3e\n    <kdebug-arg id="..." fmt="0x86a4">34468</kdebug-arg>\n    ...\n</row>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Lastly, we can take the string ID in the kdebug arg and map it back to the binary name using the ",(0,s.jsx)(n.code,{children:"kdebug-string"})," table:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- fmt attribute contains the string ID --\x3e\n<string id="1" fmt="34468">\n    <raw-string>{binary name}</raw-string>\n</string>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"finding-debug-symbols",children:"Finding Debug Symbols"}),"\n",(0,s.jsx)(n.p,{children:"The last bit before symbolicating is finding the debug symbols. For System Frameworks on iOS <17, these are stored\nunder the DeviceSupport directory. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"~/Library/Developer/Xcode/iOS\\ DeviceSupport/16.1\\ \\(20B82\\)\\ arm64e/Symbols/<libraryName>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For your own application, a ",(0,s.jsx)(n.code,{children:".dSYM"})," file can be generated by setting ",(0,s.jsx)(n.code,{children:"Debugging Information Format"})," for the XCode\nproject to ",(0,s.jsx)(n.code,{children:"DWARF with dSYM File"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"symbolicating",children:"Symbolicating"}),"\n",(0,s.jsxs)(n.p,{children:["Finally, we can symbolicate by using ",(0,s.jsx)(n.code,{children:"atos"})," which takes in a ",(0,s.jsx)(n.code,{children:".dSYM"}),", a load address and a list of addresses. For each\nbinary loaded, we need to pass the entire list of addresses observed in the backtraces. If the ",(0,s.jsx)(n.code,{children:".dSYM"})," contains a match\nfor the address, the output will contain the symbol name; otherwise, the address passed in will be returned."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# arm64e for physical devices, x86_64 for simulators on Intel macs\n# Provide a file with all possible addresses in hex format (e.g. 0x11d690681)\n# The output will contain either the original address if no match is found or the matching symbol\n#\n# Note: This is quite slow. It takes ~1m30s to process ~800 dSYMs even with parallelization on an M1.\natos -arch arm64e -o <dSymFile> -l <loadAddress> -f <file with all addresses>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["After iterating through all ",(0,s.jsx)(n.code,{children:".dSYM"})," files, the list should be fully symbolicated. Lastly, iterate through the backtraces\nusing the newly generated address to symbols mapping to complete the symbolication process. The symbolicated call stacks\ncan then be converted into arbitrary profile data formats, like\n",(0,s.jsx)(n.a,{href:"https://github.com/firefox-devtools/profiler/blob/main/docs-developer/gecko-profile-format.md",children:"Gecko"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["Overall, the approach outlined is complex and brittle. With XCode 14.3, ",(0,s.jsx)(n.code,{children:"xctrace"})," now exports symbolicated backtraces\nremoving the necessity for any of this complexity."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Example XCode 14.3+ backtrace --\x3e\n<backtrace id="182">\n    <frame id="183" name="tiny_malloc_should_clear" addr="0x7ff813c8cd06">...</frame>\n    <frame id="185" name="szone_malloc_should_clear" addr="0x7ff813c8bc3a">...</frame>\n    <frame id="186" name="__CFBasicHashRehash" addr="0x7ff813ed35a4">...</frame>\n    <frame id="188" name="__CFBasicHashAddValue" addr="0x7ff813ed3145">...</frame>\n</backtrace>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The last code for converting Instruments to Gecko can be found\n",(0,s.jsx)(n.a,{href:"https://github.com/benjaminRomano/instruments-to-gecko/tree/main",children:"here"})," and pre-XCode 14.3 implementation\n",(0,s.jsx)(n.a,{href:"https://github.com/benjaminRomano/instruments-to-gecko/tree/9ea14be77205a6313694467ac409471bad21be75",children:"here"}),"."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Special thanks to Alejandro Lucena who proposed the ",(0,s.jsx)(n.code,{children:"dyld"})," KDebug tracepoint approach for finding load addresses"]})}),"\n",(0,s.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{id:"user-content-fn-1-086523",children:["\n",(0,s.jsxs)(n.p,{children:["Debug Symbols can either be embedded within the binary using the DWARF format or exported into a debug symbols file\n(",(0,s.jsx)(n.code,{children:".dSYM"}),") ",(0,s.jsx)(n.a,{href:"#user-content-fnref-1-086523","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-2-086523",children:["\n",(0,s.jsxs)(n.p,{children:["And for good measure, usually an arbitrarily different address each time due to address space layout randomization\n(",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Address_space_layout_randomization",children:"ASLR"}),") ",(0,s.jsx)(n.a,{href:"#user-content-fnref-2-086523","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},2176:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/Inspector-3140cca337b93f3285762ade57777cc1.png"},3389:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/StackChart-42cb6502ebeb35502cd74280f860fa14.png"},7736:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/TimeProfiler-7e5955d406135d3dab92c61a4167d433.png"},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>r});var s=t(7294);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);